<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw Gateway â€” vibeclaw</title>
    <link rel="stylesheet" href="./shared-styles.css" />
    <style>
      html { font-size: 137.5%; }

      .root { display: grid; grid-template-columns: 260px 1fr 320px; gap: 1px; background: var(--border); height: calc(100vh - 44px); }

      /* â•â•â• Left sidebar â•â•â• */
      .sidebar { background: var(--surface); display: flex; flex-direction: column; overflow: hidden; }
      .sidebar-section { padding: 10px 12px; border-bottom: 1px solid var(--border); }
      .sidebar-title { font-family: var(--mono); font-size: 0.52rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 6px; }

      .gw-status { padding: 10px; background: var(--black); border: 1px solid var(--border); }
      .gw-row { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
      .gw-label { font-family: var(--mono); font-size: 0.55rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.04em; min-width: 52px; }
      .gw-val { font-family: var(--mono); font-size: 0.65rem; color: var(--text); }
      .gw-val.on { color: var(--accent); }
      .gw-val.off { color: var(--error); }
      .gw-val.warn { color: var(--warn); }

      .gw-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
      .gw-dot.on { background: var(--accent); box-shadow: 0 0 6px rgba(255,92,92,0.4); }
      .gw-dot.off { background: var(--border-bright); }
      .gw-dot.boot { background: var(--warn); animation: pulse 1.2s ease-in-out infinite; }
      @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

      .session-list { flex: 1; overflow-y: auto; padding: 0 12px 8px; display: flex; flex-direction: column; gap: 3px; scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
      .session-card { padding: 7px 9px; background: var(--black); border: 1px solid var(--border); cursor: pointer; transition: all 0.15s; }
      .session-card:hover { border-color: var(--border-bright); }
      .session-card.active { border-color: var(--accent-border); background: var(--accent-bg); }
      .sess-row { display: flex; align-items: center; gap: 5px; }
      .sess-emoji { font-size: 0.85rem; }
      .sess-name { font-family: var(--mono); font-size: 0.6rem; font-weight: 600; color: var(--text-bright); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .sess-role { font-family: var(--mono); font-size: 0.5rem; color: var(--text-dim); margin-left: auto; white-space: nowrap; }
      .sess-meta { display: flex; align-items: center; gap: 3px; margin-top: 2px; font-family: var(--mono); font-size: 0.48rem; color: var(--text-dim); }
      .sess-bar { height: 2px; background: var(--border); margin-top: 4px; overflow: hidden; }
      .sess-bar .fill { height: 100%; background: var(--accent); transition: width 0.5s; }

      .cfg-group { border-bottom: 1px solid var(--border); }
      .cfg-group-header { display: flex; align-items: center; gap: 5px; padding: 7px 12px; cursor: pointer; user-select: none; transition: background 0.1s; }
      .cfg-group-header:hover { background: rgba(255,255,255,0.02); }
      .cfg-group-header .cfg-chevron { font-size: 0.55rem; color: var(--text-dim); transition: transform 0.15s; width: 10px; }
      .cfg-group-header .cfg-group-label { font-family: var(--mono); font-size: 0.52rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); }
      .cfg-group-header .cfg-group-badge { font-family: var(--mono); font-size: 0.45rem; padding: 1px 5px; background: var(--accent-bg); color: var(--accent-dim); border: 1px solid var(--accent-border); margin-left: auto; }
      .cfg-group.open .cfg-chevron { transform: rotate(90deg); }
      .cfg-group-body { display: none; padding: 4px 12px 8px; }
      .cfg-group.open .cfg-group-body { display: block; }

      .cfg-field { display: flex; flex-direction: column; gap: 2px; margin-bottom: 6px; }
      .cfg-field label { font-family: var(--mono); font-size: 0.5rem; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-dim); }
      .cfg-field input, .cfg-field select { padding: 5px 7px; background: var(--black); border: 1px solid var(--border); color: var(--text-bright); font-family: var(--mono); font-size: 0.65rem; outline: none; width: 100%; }
      .cfg-field input:focus, .cfg-field select:focus { border-color: var(--accent-border); }
      .cfg-field input::placeholder { color: #444; }

      /* â•â•â• Center â•â•â• */
      .center { display: flex; flex-direction: column; overflow: hidden; background: var(--black); }
      .center-tabs { display: flex; background: var(--surface); border-bottom: 1px solid var(--border); flex-wrap: wrap; }
      .center-tab { padding: 8px 14px; font-family: var(--mono); font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-dim); cursor: pointer; border: none; background: none; border-bottom: 2px solid transparent; transition: all 0.15s; }
      .center-tab:hover { color: var(--text); }
      .center-tab.active { color: var(--text-bright); border-bottom-color: var(--accent); }
      .center-body { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
      .center-pane { flex: 1; display: none; flex-direction: column; overflow: hidden; }
      .center-pane.active { display: flex; }

      .chat-messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px; scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
      .msg { max-width: 88%; padding: 10px 14px; font-family: var(--mono); font-size: 0.72rem; line-height: 1.6; border: 1px solid var(--border); word-break: break-word; }
      .msg.user { align-self: flex-end; background: var(--accent-bg); border-color: var(--accent-border); color: var(--text-bright); }
      .msg.assistant { align-self: flex-start; background: var(--surface); color: var(--text); }
      .msg .msg-header { font-size: 0.55rem; color: var(--text-dim); margin-bottom: 4px; }
      .msg .msg-body { white-space: pre-wrap; }
      .msg.system { align-self: center; color: var(--text-dim); font-size: 0.6rem; border: none; background: none; padding: 4px; }
      .msg.thinking { align-self: flex-start; background: var(--surface); color: var(--text-dim); border-style: dashed; }
      .msg.thinking .msg-body::after { content: 'â€¦'; animation: blink 1s infinite; }
      @keyframes blink { 50% { opacity: 0.3; } }

      .chat-input-bar { display: flex; gap: 0; border-top: 1px solid var(--border); background: var(--surface); }
      .chat-input-bar input { flex: 1; padding: 12px 14px; background: transparent; border: none; color: var(--text-bright); font-family: var(--mono); font-size: 0.75rem; outline: none; }
      .chat-input-bar input::placeholder { color: #444; }
      .chat-input-bar .btn { padding: 12px 18px; }

      .log-viewer { flex: 1; overflow-y: auto; padding: 8px 12px; font-family: var(--mono); font-size: 0.55rem; line-height: 1.5; scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
      .log-line { padding: 1px 0; color: var(--text-dim); }
      .log-line .ts { color: #555; }
      .log-line.ok { color: var(--accent); }
      .log-line.warn { color: var(--warn); }
      .log-line.err { color: var(--error); }

      .file-viewer { flex: 1; overflow-y: auto; padding: 16px; font-family: var(--mono); font-size: 0.65rem; line-height: 1.7; color: var(--text); white-space: pre-wrap; word-break: break-word; scrollbar-width: thin; }
      .file-path-bar { padding: 6px 12px; background: rgba(0,0,0,0.3); border-bottom: 1px solid var(--border); font-family: var(--mono); font-size: 0.6rem; color: var(--text-dim); }

      /* â•â•â• Right panel â•â•â• */
      .right-panel { background: var(--surface); display: flex; flex-direction: column; overflow: hidden; }
      .right-tabs { display: flex; background: var(--black); border-bottom: 1px solid var(--border); flex-wrap: wrap; }
      .right-tab { padding: 7px 10px; font-family: var(--mono); font-size: 0.5rem; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-dim); cursor: pointer; border: none; background: none; border-bottom: 2px solid transparent; transition: all 0.15s; }
      .right-tab:hover { color: var(--text); }
      .right-tab.active { color: var(--text-bright); border-bottom-color: var(--accent); }
      .right-body { flex: 1; overflow: hidden; }
      .right-pane { display: none; flex-direction: column; overflow-y: auto; height: 100%; padding: 8px; scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
      .right-pane.active { display: flex; }

      .ctx-item { padding: 6px 8px; background: var(--black); border: 1px solid var(--border); margin-bottom: 4px; }
      .ctx-label { font-family: var(--mono); font-size: 0.5rem; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-dim); margin-bottom: 2px; }
      .ctx-body { font-family: var(--mono); font-size: 0.55rem; color: var(--text); line-height: 1.5; white-space: pre-wrap; max-height: 140px; overflow-y: auto; scrollbar-width: thin; }

      .skill-item { padding: 5px 8px; background: var(--black); border: 1px solid var(--border); margin-bottom: 3px; display: flex; align-items: center; gap: 6px; }
      .skill-item .skill-emoji { font-size: 0.8rem; }
      .skill-item .skill-name { font-family: var(--mono); font-size: 0.58rem; font-weight: 600; color: var(--text-bright); }
      .skill-item .skill-desc { font-family: var(--mono); font-size: 0.48rem; color: var(--text-dim); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .skill-item .skill-badge { font-family: var(--mono); font-size: 0.42rem; padding: 1px 4px; margin-left: auto; flex-shrink: 0; }
      .skill-badge.eligible { background: var(--accent-bg); color: var(--accent-dim); border: 1px solid var(--accent-border); }
      .skill-badge.missing { background: rgba(232,200,114,0.06); color: var(--warn); border: 1px solid rgba(232,200,114,0.15); }

      .cron-item { padding: 6px 8px; background: var(--black); border: 1px solid var(--border); margin-bottom: 3px; }
      .cron-name { font-family: var(--mono); font-size: 0.6rem; font-weight: 600; color: var(--text-bright); }
      .cron-meta { font-family: var(--mono); font-size: 0.48rem; color: var(--text-dim); margin-top: 2px; }
      .cron-status { font-family: var(--mono); font-size: 0.48rem; margin-top: 2px; }

      .metrics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; }
      .metric-card { padding: 8px; background: var(--black); border: 1px solid var(--border); text-align: center; }
      .metric-val { font-family: var(--mono); font-size: 1rem; font-weight: 700; color: var(--text-bright); }
      .metric-label { font-family: var(--mono); font-size: 0.48rem; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-dim); margin-top: 2px; }

      .presence-item { padding: 5px 8px; background: var(--black); border: 1px solid var(--border); margin-bottom: 3px; font-family: var(--mono); }
      .presence-item .p-host { font-size: 0.58rem; font-weight: 600; color: var(--text-bright); }
      .presence-item .p-meta { font-size: 0.48rem; color: var(--text-dim); }

      /* Responsive */
      @media (max-width: 1100px) { .root { grid-template-columns: 220px 1fr; } .right-panel { display: none; } }
      @media (max-width: 700px) { .root { grid-template-columns: 1fr; } .sidebar { display: none; } }
    </style>
  </head>
  <body>
    <div class="demo-topbar">
      <a href="./index.html" class="back">â† demos</a>
      <span class="sep">/</span>
      <a href="../index.html" class="logo">ğŸ¦€ vibeclaw</a>
      <span class="sep">/</span>
      <span class="title">OpenClaw Gateway</span>
      <span class="tag">openclaw Â· gateway Â· dashboard Â· live</span>
    </div>

    <div class="root">
      <!-- â•â•â• Left sidebar â•â•â• -->
      <div class="sidebar">
        <form autocomplete="off" onsubmit="return false;">
          <!-- Connection -->
          <div class="cfg-group open">
            <div class="cfg-group-header" onclick="this.parentElement.classList.toggle('open')">
              <span class="cfg-chevron">â–¶</span>
              <span class="cfg-group-label">Connection</span>
              <span class="cfg-group-badge" id="connBadge">offline</span>
            </div>
            <div id="connForm" class="cfg-group-body">
              <div class="cfg-field">
                <label>Gateway URL</label>
                <input id="gwUrl" type="text" value="local" placeholder="local, ws://host:port" />
              </div>
              <div style="font-family:var(--mono);font-size:0.42rem;color:var(--text-dim);padding:0 0 4px;">"local" â†’ Vite proxy â†’ localhost:18789</div>
              <div class="cfg-field">
                <label>Token</label>
                <input id="gwToken" type="password" placeholder="paste from gateway dashboard" autocomplete="off" />
              </div>
              <div style="padding-top:4px;">
                <button id="connectBtn" class="btn btn-primary" style="width:100%;">Connect</button>
                <button id="disconnectBtn" class="btn btn-warn" style="width:100%;display:none;">Disconnect</button>
              </div>
            </div>
          </div>
        </form>

        <!-- Status -->
        <div class="sidebar-section">
          <div class="sidebar-title">Status</div>
          <div class="gw-status" id="gwStatus">
            <div class="gw-row"><span class="gw-label">State</span><span class="gw-dot off" id="gwDot"></span><span class="gw-val off" id="gwStateVal">Offline</span></div>
            <div class="gw-row"><span class="gw-label">Server</span><span class="gw-val" id="gwServer">â€”</span></div>
            <div class="gw-row"><span class="gw-label">Agent</span><span class="gw-val" id="gwAgent">â€”</span></div>
            <div class="gw-row"><span class="gw-label">Model</span><span class="gw-val" id="gwModel">â€”</span></div>
            <div class="gw-row"><span class="gw-label">Sessions</span><span class="gw-val" id="gwSessionCount">0</span></div>
            <div class="gw-row"><span class="gw-label">Channels</span><span class="gw-val" id="gwChannels">â€”</span></div>
          </div>
        </div>

        <!-- Sessions list -->
        <div class="sidebar-section" style="flex:0;padding-bottom:2px;">
          <div class="sidebar-title">Sessions</div>
        </div>
        <div class="session-list" id="sessionList">
          <div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px 0;">Connect to see sessions</div>
        </div>
      </div>

      <!-- â•â•â• Center â•â•â• -->
      <div class="center">
        <div class="center-tabs">
          <button class="center-tab active" data-pane="chat">ğŸ’¬ Chat</button>
          <button class="center-tab" data-pane="history">ğŸ“œ History</button>
          <button class="center-tab" data-pane="files">ğŸ“ Files</button>
          <button class="center-tab" data-pane="logs">ğŸ“‹ Logs</button>
        </div>
        <div class="center-body">
          <div class="center-pane active" id="pane-chat">
            <div class="chat-messages" id="chatMessages">
              <div class="msg system">Connect to the gateway to begin</div>
            </div>
            <div class="chat-input-bar">
              <input id="chatInput" type="text" placeholder="Messageâ€¦" disabled />
              <button id="chatSend" class="btn btn-primary" disabled>Send</button>
            </div>
          </div>
          <div class="center-pane" id="pane-history">
            <div class="chat-messages" id="historyMessages">
              <div class="msg system">Select a session to view history</div>
            </div>
          </div>
          <div class="center-pane" id="pane-files">
            <div class="file-path-bar" id="filePath">Agent workspace files</div>
            <div class="file-viewer" id="fileViewer">Connect to browse files</div>
          </div>
          <div class="center-pane" id="pane-logs">
            <div class="log-viewer" id="logViewer">
              <div class="log-line"><span class="ts">[--:--]</span> Gateway not connected</div>
            </div>
          </div>
        </div>
      </div>

      <!-- â•â•â• Right panel â•â•â• -->
      <div class="right-panel">
        <div class="right-tabs">
          <button class="right-tab active" data-pane="context">Context</button>
          <button class="right-tab" data-pane="skills">Skills</button>
          <button class="right-tab" data-pane="cron">Cron</button>
          <button class="right-tab" data-pane="metrics">Metrics</button>
          <button class="right-tab" data-pane="presence">Nodes</button>
        </div>
        <div class="right-body">
          <div class="right-pane active" id="rpane-context" style="gap:4px;"></div>
          <div class="right-pane" id="rpane-skills" style="gap:3px;"></div>
          <div class="right-pane" id="rpane-cron" style="gap:3px;"></div>
          <div class="right-pane" id="rpane-metrics"></div>
          <div class="right-pane" id="rpane-presence" style="gap:3px;"></div>
        </div>
      </div>
    </div>

    <script type="module">
      import { OpenClawClient } from './openclaw-client.js';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  STATE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let client = null;
      let activeSession = 'agent:main:main';
      let agentIdentity = {};      // agentId â†’ { name, emoji }
      let sessionsList = [];       // from sessions.list
      let streamingEl = null;
      let streamingText = '';
      let logCursor = 0;
      let logs = [];
      let refreshTimer = null;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  DOM
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const $ = id => document.getElementById(id);
      const el = {
        gwUrl: $('gwUrl'), gwToken: $('gwToken'),
        connectBtn: $('connectBtn'), disconnectBtn: $('disconnectBtn'), connBadge: $('connBadge'),
        gwDot: $('gwDot'), gwStateVal: $('gwStateVal'), gwServer: $('gwServer'),
        gwAgent: $('gwAgent'), gwModel: $('gwModel'), gwSessionCount: $('gwSessionCount'), gwChannels: $('gwChannels'),
        sessionList: $('sessionList'),
        chatMessages: $('chatMessages'), chatInput: $('chatInput'), chatSend: $('chatSend'),
        historyMessages: $('historyMessages'),
        filePath: $('filePath'), fileViewer: $('fileViewer'),
        logViewer: $('logViewer'),
      };
      const rpane = { context: $('rpane-context'), skills: $('rpane-skills'), cron: $('rpane-cron'), metrics: $('rpane-metrics'), presence: $('rpane-presence') };

      function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
      function ts() { return new Date().toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'}); }
      function fmtAge(ms) { const s=Math.floor(ms/1000); if(s<60) return s+'s'; const m=Math.floor(s/60); if(m<60) return m+'m'; return Math.floor(m/60)+'h '+m%60+'m'; }
      function fmtNum(n) { return n>=1e6?(n/1e6).toFixed(1)+'M':n>=1e3?(n/1e3).toFixed(1)+'k':String(n); }
      function fmtCost(n) { return '$'+n.toFixed(2); }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  TABS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function initTabs(sel, prefix) {
        document.querySelectorAll(sel).forEach(tab => {
          tab.addEventListener('click', () => {
            document.querySelectorAll(sel).forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            document.querySelectorAll(`[id^="${prefix}"]`).forEach(p => p.classList.remove('active'));
            const target = $(prefix + tab.dataset.pane);
            if (target) target.classList.add('active');
          });
        });
      }
      initTabs('.center-tab', 'pane-');
      initTabs('.right-tab', 'rpane-');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  LOGGING (local UI log)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function log(level, msg) {
        logs.push({ ts: ts(), level, msg });
        if (logs.length > 300) logs.shift();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  CONNECTION STATE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function setState(state) {
        const isOn = state === 'connected';
        const isBoot = state === 'connecting';
        el.gwDot.className = `gw-dot ${isOn ? 'on' : isBoot ? 'boot' : 'off'}`;
        el.gwStateVal.className = `gw-val ${isOn ? 'on' : isBoot ? 'warn' : 'off'}`;
        el.gwStateVal.textContent = state.charAt(0).toUpperCase() + state.slice(1);
        el.connBadge.textContent = state;
        el.connectBtn.style.display = isOn || isBoot ? 'none' : '';
        el.disconnectBtn.style.display = isOn ? '' : 'none';
        el.chatInput.disabled = !isOn;
        el.chatSend.disabled = !isOn;
        el.gwUrl.disabled = isOn || isBoot;
        el.gwToken.disabled = isOn || isBoot;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  CHAT HELPERS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function appendMsg(container, type, header, body) {
        const div = document.createElement('div');
        div.className = `msg ${type}`;
        if (type === 'system') { div.textContent = body || header; }
        else { div.innerHTML = `<div class="msg-header">${esc(header)}</div><div class="msg-body">${esc(body)}</div>`; }
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
        return div;
      }

      function clearChat() { el.chatMessages.innerHTML = ''; }

      function agentLabel() {
        const m = activeSession.match(/^agent:(\w+):/);
        const id = m ? m[1] : 'main';
        const a = agentIdentity[id];
        return a ? `${a.emoji || 'âœ¨'} ${a.name}` : `ğŸ¦€ ${id}`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  CONNECT
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BroadcastChannel WebSocket shim for sandbox mode
      class SandboxSocket {
        constructor() {
          this.ch = new BroadcastChannel('vibeclaw-gw');
          this.readyState = 1;
          this.onmessage = null;
          this.onclose = null;
          this.onerror = null;
          this.ch.onmessage = (e) => {
            if (this.onmessage) this.onmessage({ data: JSON.stringify(e.data) });
          };
          // Tell sandbox we're here
          setTimeout(() => this.ch.postMessage({ type: 'ping' }), 50);
        }
        send(data) { this.ch.postMessage(JSON.parse(data)); }
        close() { this.ch.close(); this.readyState = 3; if (this.onclose) this.onclose({ code: 1000, reason: '' }); }
      }

      async function connect() {
        const rawUrl = el.gwUrl.value.trim();
        const token = el.gwToken.value.trim();
        if (!rawUrl) { el.gwUrl.focus(); return; }
        if (rawUrl !== 'sandbox' && !token) { el.gwToken.focus(); return; }

        const isSandbox = rawUrl === 'sandbox';
        const url = isSandbox ? 'sandbox'
          : (rawUrl === 'local' || rawUrl === 'localhost')
            ? `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/openclaw-ws`
            : rawUrl;

        setState('connecting');
        clearChat();
        appendMsg(el.chatMessages, 'system', '', isSandbox ? 'Connecting to sandboxâ€¦' : `Connecting to ${url}â€¦`);
        log('info', `Connecting to ${url}`);

        if (isSandbox) {
          // Direct BroadcastChannel â€” no OpenClawClient needed
          const sock = new SandboxSocket();
          client = {
            connected: false,
            ws: sock,
            disconnect() { sock.close(); this.connected = false; },
            request(method, params) {
              return new Promise((resolve, reject) => {
                const id = String(Math.random().toString(36).slice(2, 8));
                const handler = (e) => {
                  const msg = e.data;
                  if (msg.type === 'res' && msg.id === id) {
                    sock.ch.removeEventListener('message', handler);
                    if (msg.ok) resolve(msg.payload); else reject(new Error(msg.error?.message || 'failed'));
                  }
                };
                sock.ch.addEventListener('message', handler);
                sock.ch.postMessage({ type: 'req', id, method, params: params || {} });
              });
            },
            chat(message, opts) { return this.request('chat.send', { sessionKey: opts?.sessionKey || 'main', message }); },
            status() { return this.request('status'); },
            sessions() { return this.request('sessions.list'); },
            health() { return this.request('health'); },
            agents() { return this.request('agents.list'); },
          };

          // Handle chat events from sandbox
          sock.ch.addEventListener('message', (e) => {
            const msg = e.data;
            if (msg.type === 'event' && msg.event === 'chat') {
              const payload = msg.payload;
              if (payload?.state === 'delta' && payload?.message) {
                const content = payload.message.content;
                let text = typeof content === 'string' ? content : Array.isArray(content) ? content.map(c => c.text || '').join('') : '';
                if (text && text.length > streamingText.length) {
                  streamingText = text;
                  if (streamingEl?.classList.contains('thinking')) {
                    streamingEl.classList.remove('thinking');
                    streamingEl.classList.add('assistant');
                    const hdr = streamingEl.querySelector('.msg-header');
                    if (hdr) hdr.textContent = agentLabel();
                  }
                  if (streamingEl) {
                    const body = streamingEl.querySelector('.msg-body');
                    if (body) body.textContent = streamingText;
                    el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
                  }
                }
              }
              if (payload?.state === 'final' || payload?.state === 'aborted') {
                if (streamingText && streamingEl) {
                  streamingEl.classList.remove('thinking');
                  streamingEl.classList.add('assistant');
                  const hdr = streamingEl.querySelector('.msg-header');
                  if (hdr) hdr.textContent = agentLabel();
                  const body = streamingEl.querySelector('.msg-body');
                  if (body) body.textContent = streamingText;
                } else if (streamingEl) { streamingEl.remove(); }
                streamingEl = null; streamingText = '';
                el.chatInput.disabled = false; el.chatSend.disabled = false; el.chatInput.focus();
              }
              if (payload?.state === 'error') {
                if (streamingEl) streamingEl.remove();
                appendMsg(el.chatMessages, 'system', '', `Error: ${payload.errorMessage || 'unknown'}`);
                streamingEl = null; streamingText = '';
                el.chatInput.disabled = false; el.chatSend.disabled = false;
              }
            }
          });

          // Wait for challenge then auto-connect
          sock.ch.addEventListener('message', async function once(e) {
            if (e.data?.type === 'event' && e.data?.event === 'connect.challenge') {
              sock.ch.removeEventListener('message', once);
              try {
                const hello = await client.request('connect', { minProtocol: 3, maxProtocol: 3 });
                client.connected = true;
                setState('connected');
                el.gwServer.textContent = 'sandbox';
                log('ok', 'Connected to sandbox');
                appendMsg(el.chatMessages, 'system', '', 'ğŸ¦€ Connected to sandbox');
                if (hello?.mainSessionKey) activeSession = hello.mainSessionKey;
                await Promise.all([fetchStatus(), fetchAgentIdentity(), fetchSessions(), fetchAgentFiles(), fetchSkills(), fetchCron(), fetchUsageCost(), fetchLogs(), fetchPresence()]);
              } catch (err) {
                setState('offline');
                appendMsg(el.chatMessages, 'system', '', 'Connection failed: ' + err.message);
              }
            }
          });
          return;
        }

        client = new OpenClawClient({
          url, token,

          onChat: (payload) => {
            if (payload?.state === 'delta' && payload?.message) {
              const content = payload.message.content;
              let text = '';
              if (typeof content === 'string') text = content;
              else if (Array.isArray(content)) text = content.map(c => c.text || '').join('');
              if (text && text.length > streamingText.length) {
                streamingText = text;
                if (streamingEl?.classList.contains('thinking')) {
                  streamingEl.classList.remove('thinking');
                  streamingEl.classList.add('assistant');
                  const hdr = streamingEl.querySelector('.msg-header');
                  if (hdr) hdr.textContent = agentLabel();
                }
                if (streamingEl) {
                  const body = streamingEl.querySelector('.msg-body');
                  if (body) body.textContent = streamingText;
                  el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
                }
              }
            }
            if (payload?.state === 'final' || payload?.state === 'aborted') {
              if (streamingText && streamingEl) {
                streamingEl.classList.remove('thinking');
                streamingEl.classList.add('assistant');
                const hdr = streamingEl.querySelector('.msg-header');
                if (hdr) hdr.textContent = agentLabel();
                const body = streamingEl.querySelector('.msg-body');
                if (body) body.textContent = streamingText;
              } else if (streamingEl) { streamingEl.remove(); }
              streamingEl = null; streamingText = '';
              el.chatInput.disabled = false; el.chatSend.disabled = false; el.chatInput.focus();
            }
            if (payload?.state === 'error') {
              if (streamingEl) streamingEl.remove();
              appendMsg(el.chatMessages, 'system', '', `Error: ${payload.errorMessage || 'unknown'}`);
              streamingEl = null; streamingText = '';
              el.chatInput.disabled = false; el.chatSend.disabled = false;
            }
          },

          onEvent: (event, payload) => {
            log('info', `Event: ${event}`);
          },

          onConnect: async (hello) => {
            const server = hello?.server?.host || url;
            setState('connected');
            el.gwServer.textContent = server;
            log('ok', `Connected to ${server}`);
            appendMsg(el.chatMessages, 'system', '', `ğŸ¦€ Connected to ${server}`);
            if (hello?.mainSessionKey) activeSession = hello.mainSessionKey;

            // Fetch everything
            await Promise.all([
              fetchStatus(),
              fetchAgentIdentity(),
              fetchSessions(),
              fetchAgentFiles(),
              fetchSkills(),
              fetchCron(),
              fetchUsageCost(),
              fetchPresence(),
              fetchLogs(),
            ]);

            // Load chat history for active session
            await loadSessionChat(activeSession);
            el.chatInput.focus();
            // Start periodic refresh
            refreshTimer = setInterval(periodicRefresh, 8000);
          },

          onDisconnect: ({ code, reason }) => {
            setState('offline');
            appendMsg(el.chatMessages, 'system', '', `Disconnected (${code}): ${reason || 'closed'}`);
            log('warn', `Disconnected: ${reason || code}`);
            clearRefresh();
          },

          onError: (err) => log('err', `Error: ${err.message}`),
        });

        try {
          await client.connect();
        } catch (err) {
          setState('offline');
          appendMsg(el.chatMessages, 'system', '', `Connection failed: ${err.message}`);
          log('err', `Connect failed: ${err.message}`);
          client = null;
        }
      }

      function disconnect() {
        clearRefresh();
        if (client) { client.disconnect(); client = null; }
        setState('offline');
        el.gwServer.textContent = 'â€”'; el.gwAgent.textContent = 'â€”'; el.gwModel.textContent = 'â€”';
        el.gwSessionCount.textContent = '0'; el.gwChannels.textContent = 'â€”';
        el.sessionList.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px 0;">Disconnected</div>';
      }

      function clearRefresh() { if (refreshTimer) { clearInterval(refreshTimer); refreshTimer = null; } }

      async function periodicRefresh() {
        if (!client?.connected) return;
        await Promise.all([fetchStatus(), fetchSessions(), fetchLogs(), fetchPresence()]);
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  API FETCHERS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      async function req(method, params = {}) {
        if (!client?.connected) throw new Error('not connected');
        return client.request(method, params);
      }

      async function fetchStatus() {
        try {
          const s = await req('status');
          const model = s?.sessions?.defaults?.model || '?';
          const count = s?.sessions?.count || 0;
          el.gwModel.textContent = model;
          el.gwSessionCount.textContent = count;
          // Channels
          const channels = s?.channelSummary || [];
          el.gwChannels.textContent = channels.length ? channels[0].split(':')[0] : 'none';
          // Heartbeat
          const hb = s?.heartbeat;
          if (hb?.defaultAgentId) {
            el.gwAgent.textContent = hb.defaultAgentId;
          }
        } catch (e) { log('warn', `status: ${e.message}`); }
      }

      async function fetchAgentIdentity() {
        try {
          const agents = await req('agents.list');
          for (const a of (agents?.agents || [])) {
            try {
              const id = await req('agent.identity.get', { agentId: a.id });
              agentIdentity[a.id] = id;
            } catch {}
          }
          const main = agentIdentity.main || agentIdentity[Object.keys(agentIdentity)[0]];
          if (main) {
            el.gwAgent.textContent = `${main.emoji || ''} ${main.name || 'Agent'}`;
          }
        } catch (e) { log('warn', `agents: ${e.message}`); }
      }

      async function fetchSessions() {
        try {
          const r = await req('sessions.list');
          sessionsList = r?.sessions || [];
          renderSessions();
        } catch (e) { log('warn', `sessions: ${e.message}`); }
      }

      function renderSessions() {
        if (!sessionsList.length) {
          el.sessionList.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px 0;">No sessions</div>';
          return;
        }
        el.sessionList.innerHTML = sessionsList.map(s => {
          const key = s.key;
          const sel = key === activeSession ? 'active' : '';
          const label = s.displayName || s.label || s.key;
          const tokens = s.totalTokens ? fmtNum(s.totalTokens) + ' tok' : '';
          const model = s.model || '';
          const age = s.updatedAt ? fmtAge(Date.now() - s.updatedAt) + ' ago' : '';
          return `<div class="session-card ${sel}" data-key="${esc(key)}">
            <div class="sess-row"><span class="sess-name">${esc(label)}</span></div>
            <div class="sess-meta">${[tokens, model, age].filter(Boolean).join(' Â· ')}</div>
            ${s.totalTokens && s.contextTokens ? `<div class="sess-bar"><div class="fill" style="width:${Math.min(100,Math.round(s.totalTokens/s.contextTokens*100))}%"></div></div>` : ''}
          </div>`;
        }).join('');

        el.sessionList.querySelectorAll('.session-card').forEach(card => {
          card.addEventListener('click', () => {
            activeSession = card.dataset.key;
            renderSessions();
            loadSessionChat(activeSession);
          });
        });
      }

      async function loadSessionChat(sessionKey) {
        try {
          const r = await req('chat.history', { sessionKey, limit: 50 });
          const msgs = r?.messages || [];

          // Load into main chat pane
          clearChat();
          const sess = sessionsList.find(s => s.key === sessionKey);
          appendMsg(el.chatMessages, 'system', '', `Session: ${sess?.displayName || sess?.label || sessionKey}`);

          // Load into history pane
          el.historyMessages.innerHTML = '';

          if (!msgs.length) {
            appendMsg(el.chatMessages, 'system', '', 'No messages yet â€” start chatting');
            appendMsg(el.historyMessages, 'system', '', 'No messages in this session');
            return;
          }

          for (const m of msgs) {
            const text = Array.isArray(m.content)
              ? m.content.map(c => c.text || '').join('')
              : (typeof m.content === 'string' ? m.content : '');
            if (!text) continue;
            const type = m.role === 'user' ? 'user' : 'assistant';
            const header = m.role === 'user' ? 'You' : agentLabel();
            const time = m.timestamp ? new Date(m.timestamp).toLocaleTimeString('en-GB', {hour:'2-digit',minute:'2-digit'}) : '';
            const cost = m.usage?.cost?.total ? ` Â· ${fmtCost(m.usage.cost.total)}` : '';

            // Chat pane â€” show last few messages for context
            appendMsg(el.chatMessages, type, `${header} ${time}`, text.slice(0, 2000));

            // History pane â€” full detail with cost
            appendMsg(el.historyMessages, type, `${header} ${time}${cost}`, text.slice(0, 2000));
          }

          // Scroll both to bottom
          el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
          el.historyMessages.scrollTop = el.historyMessages.scrollHeight;
        } catch (e) {
          appendMsg(el.chatMessages, 'system', '', `History: ${e.message}`);
          el.historyMessages.innerHTML = '';
          appendMsg(el.historyMessages, 'system', '', `History error: ${e.message}`);
        }
      }

      async function fetchAgentFiles() {
        try {
          // Get main agent's files
          const agentId = activeSession.match(/^agent:(\w+):/)?.[1] || 'main';
          const r = await req('agents.files.list', { agentId });
          const files = r?.files || [];

          // Show as clickable list in file viewer
          el.filePath.textContent = `Agent workspace: ${r?.workspace || agentId}`;
          el.fileViewer.innerHTML = files.map(f => {
            if (f.missing) return '';
            const icon = 'ğŸ“„';
            const size = f.size ? ` (${fmtNum(f.size)} bytes)` : '';
            return `<div class="file-entry" data-agent="${esc(agentId)}" data-name="${esc(f.name)}" style="cursor:pointer;padding:3px 0;color:var(--accent);text-decoration:underline;">${icon} ${esc(f.name)}${size}</div>`;
          }).join('') || 'No files';

          el.fileViewer.querySelectorAll('.file-entry').forEach(entry => {
            entry.addEventListener('click', () => viewAgentFile(entry.dataset.agent, entry.dataset.name));
          });

          // Also populate context panel
          renderContext(agentId, files);
        } catch (e) { log('warn', `files: ${e.message}`); }
      }

      async function viewAgentFile(agentId, name) {
        try {
          const r = await req('agents.files.get', { agentId, name });
          const content = r?.file?.content || '(empty)';
          el.filePath.textContent = `${r?.workspace || agentId}/${name}`;
          el.fileViewer.innerHTML = content.split('\n').map((line, i) =>
            `<span style="display:inline-block;width:28px;color:#444;text-align:right;margin-right:10px;user-select:none;">${i+1}</span>${esc(line)}`
          ).join('\n');
          // Switch to files tab
          document.querySelectorAll('.center-tab').forEach(t => t.classList.remove('active'));
          document.querySelector('.center-tab[data-pane="files"]').classList.add('active');
          document.querySelectorAll('[id^="pane-"]').forEach(p => p.classList.remove('active'));
          $('pane-files').classList.add('active');
        } catch (e) {
          el.fileViewer.textContent = `Error: ${e.message}`;
        }
      }

      async function renderContext(agentId, files) {
        const ctx = rpane.context;
        ctx.innerHTML = '';
        for (const f of files) {
          if (f.missing || !f.size) continue;
          try {
            const r = await req('agents.files.get', { agentId, name: f.name });
            const content = r?.file?.content || '';
            if (!content) continue;
            ctx.innerHTML += `<div class="ctx-item"><div class="ctx-label">${esc(f.name)}</div><div class="ctx-body">${esc(content)}</div></div>`;
          } catch {}
        }
        if (!ctx.innerHTML) ctx.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px;">No context files</div>';
      }

      async function fetchSkills() {
        try {
          const r = await req('skills.status');
          const skills = r?.skills || [];
          const eligible = skills.filter(s => s.eligible && !s.disabled);
          const other = skills.filter(s => !s.eligible || s.disabled);
          rpane.skills.innerHTML = '';
          if (eligible.length) {
            rpane.skills.innerHTML += `<div style="font-family:var(--mono);font-size:0.48rem;color:var(--text-dim);padding:2px 0;text-transform:uppercase;">Active (${eligible.length})</div>`;
            rpane.skills.innerHTML += eligible.map(s => `<div class="skill-item">
              <span class="skill-emoji">${s.emoji || 'ğŸ”§'}</span>
              <div style="flex:1;min-width:0;"><div class="skill-name">${esc(s.name)}</div><div class="skill-desc">${esc((s.description||'').slice(0,80))}</div></div>
              <span class="skill-badge eligible">${s.source || 'active'}</span>
            </div>`).join('');
          }
          if (other.length) {
            rpane.skills.innerHTML += `<div style="font-family:var(--mono);font-size:0.48rem;color:var(--text-dim);padding:4px 0 2px;text-transform:uppercase;">Available (${other.length})</div>`;
            rpane.skills.innerHTML += other.slice(0, 30).map(s => {
              const reason = s.disabled ? 'disabled' : (s.missing?.bins?.length ? 'missing: ' + s.missing.bins.join(',') : 'not eligible');
              return `<div class="skill-item" style="opacity:0.5;">
                <span class="skill-emoji">${s.emoji || 'ğŸ”§'}</span>
                <div style="flex:1;min-width:0;"><div class="skill-name">${esc(s.name)}</div><div class="skill-desc">${esc(reason)}</div></div>
              </div>`;
            }).join('');
            if (other.length > 30) rpane.skills.innerHTML += `<div style="font-family:var(--mono);font-size:0.48rem;color:var(--text-dim);padding:2px 0;">â€¦and ${other.length - 30} more</div>`;
          }
          if (!skills.length) rpane.skills.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px;">No skills</div>';
        } catch (e) { rpane.skills.innerHTML = `<div style="color:var(--error);font-size:0.55rem;">${esc(e.message)}</div>`; }
      }

      async function fetchCron() {
        try {
          const r = await req('cron.list');
          const jobs = r?.jobs || [];
          if (!jobs.length) { rpane.cron.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px;">No cron jobs</div>'; return; }
          rpane.cron.innerHTML = jobs.map(j => {
            const every = j.schedule?.everyMs ? fmtAge(j.schedule.everyMs) : '?';
            const next = j.state?.nextRunAtMs ? fmtAge(j.state.nextRunAtMs - Date.now()) : '?';
            const last = j.state?.lastStatus || 'never';
            const lastDur = j.state?.lastDurationMs ? fmtAge(j.state.lastDurationMs) : '';
            const statusCls = last === 'ok' ? 'color:var(--accent)' : last === 'error' ? 'color:var(--error)' : '';
            return `<div class="cron-item">
              <div class="cron-name">${j.enabled ? 'âœ…' : 'â¸ï¸'} ${esc(j.name || j.id)}</div>
              <div class="cron-meta">Agent: ${esc(j.agentId)} Â· Every ${every} Â· Next: ${next}</div>
              <div class="cron-status" style="${statusCls}">Last: ${last} ${lastDur ? '(' + lastDur + ')' : ''}</div>
              <div class="cron-meta" style="margin-top:3px;">${esc((j.payload?.message || '').slice(0, 120))}</div>
            </div>`;
          }).join('');
        } catch (e) { rpane.cron.innerHTML = `<div style="color:var(--error);font-size:0.55rem;">${esc(e.message)}</div>`; }
      }

      async function fetchUsageCost() {
        try {
          const r = await req('usage.cost');
          const daily = r?.daily || [];
          const totalCost = daily.reduce((s, d) => s + (d.totalCost || 0), 0);
          const totalTokens = daily.reduce((s, d) => s + (d.totalTokens || 0), 0);
          const days = daily.length;
          const todayCost = daily[daily.length - 1]?.totalCost || 0;
          const todayTokens = daily[daily.length - 1]?.totalTokens || 0;

          rpane.metrics.innerHTML = `
            <div class="metrics-grid">
              <div class="metric-card"><div class="metric-val">${fmtCost(todayCost)}</div><div class="metric-label">Today Cost</div></div>
              <div class="metric-card"><div class="metric-val">${fmtNum(todayTokens)}</div><div class="metric-label">Today Tokens</div></div>
              <div class="metric-card"><div class="metric-val">${fmtCost(totalCost)}</div><div class="metric-label">${days}d Total Cost</div></div>
              <div class="metric-card"><div class="metric-val">${fmtNum(totalTokens)}</div><div class="metric-label">${days}d Total Tokens</div></div>
              <div class="metric-card"><div class="metric-val">${days > 0 ? fmtCost(totalCost / days) : 'â€”'}</div><div class="metric-label">Avg/Day</div></div>
              <div class="metric-card"><div class="metric-val">${sessionsList.length}</div><div class="metric-label">Sessions</div></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-family:var(--mono);font-size:0.48rem;color:var(--text-dim);text-transform:uppercase;margin-bottom:4px;">Daily Cost (${days}d)</div>
              <div style="display:flex;align-items:flex-end;gap:1px;height:40px;">
                ${daily.slice(-14).map(d => {
                  const max = Math.max(...daily.slice(-14).map(x => x.totalCost || 0), 0.01);
                  const h = Math.max(1, Math.round((d.totalCost || 0) / max * 40));
                  return `<div style="flex:1;height:${h}px;background:var(--accent-border);" title="${d.date}: ${fmtCost(d.totalCost||0)}"></div>`;
                }).join('')}
              </div>
            </div>
          `;
        } catch (e) { rpane.metrics.innerHTML = `<div style="color:var(--error);font-size:0.55rem;">${esc(e.message)}</div>`; }
      }

      async function fetchPresence() {
        try {
          const r = await req('system-presence');
          const items = Array.isArray(r) ? r : [];
          if (!items.length) { rpane.presence.innerHTML = '<div style="font-family:var(--mono);font-size:0.55rem;color:var(--text-dim);padding:4px;">No nodes</div>'; return; }
          // Dedupe by host+deviceId, show most recent
          const seen = new Map();
          for (const p of items) {
            const key = p.host + (p.deviceId || '');
            if (!seen.has(key) || p.ts > seen.get(key).ts) seen.set(key, p);
          }
          rpane.presence.innerHTML = [...seen.values()].map(p => {
            const age = p.ts ? fmtAge(Date.now() - p.ts) + ' ago' : '';
            const reason = p.reason || '';
            const dot = reason === 'connect' || reason === 'self' ? 'ğŸŸ¢' : 'âšª';
            return `<div class="presence-item">
              <div class="p-host">${dot} ${esc(p.host)}</div>
              <div class="p-meta">${[p.mode, p.platform, p.ip, age].filter(Boolean).join(' Â· ')}</div>
            </div>`;
          }).join('');
        } catch (e) { rpane.presence.innerHTML = `<div style="color:var(--error);font-size:0.55rem;">${esc(e.message)}</div>`; }
      }

      async function fetchLogs() {
        try {
          const r = await req('logs.tail', { limit: 50, cursor: logCursor || undefined });
          if (r?.cursor) logCursor = r.cursor;
          const lines = r?.lines || [];
          for (const raw of lines) {
            try {
              const parsed = JSON.parse(raw);
              const time = parsed.time ? new Date(parsed.time).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'}) : '??:??';
              const level = parsed._meta?.logLevelName || 'INFO';
              const text = parsed['2'] || parsed['1'] || '';
              const msg = typeof text === 'string' ? text : JSON.stringify(text).slice(0, 200);
              const cls = level === 'WARN' ? 'warn' : level === 'ERROR' ? 'err' : level === 'DEBUG' ? '' : 'ok';
              logs.push({ ts: time, level: cls, msg: msg.slice(0, 200) });
            } catch {
              logs.push({ ts: ts(), level: '', msg: raw.slice(0, 200) });
            }
          }
          if (logs.length > 300) logs = logs.slice(-300);
          renderLogs();
        } catch (e) { /* silent */ }
      }

      function renderLogs() {
        el.logViewer.innerHTML = logs.slice(-100).map(l =>
          `<div class="log-line ${l.level}"><span class="ts">[${l.ts}]</span> ${esc(l.msg)}</div>`
        ).join('');
        el.logViewer.scrollTop = el.logViewer.scrollHeight;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  SEND CHAT
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      async function sendChat() {
        const text = el.chatInput.value.trim();
        if (!text || !client?.connected) return;
        el.chatInput.value = '';

        appendMsg(el.chatMessages, 'user', 'You', text);
        log('info', `â†’ "${text.slice(0, 80)}"`);

        el.chatInput.disabled = true;
        el.chatSend.disabled = true;
        streamingText = '';
        streamingEl = appendMsg(el.chatMessages, 'thinking', agentLabel(), 'Thinking');

        try {
          await client.chat(text, { sessionKey: activeSession });
        } catch (err) {
          if (streamingEl) streamingEl.remove();
          streamingEl = null; streamingText = '';
          appendMsg(el.chatMessages, 'system', '', `Send failed: ${err.message}`);
          el.chatInput.disabled = false; el.chatSend.disabled = false;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  WIRING
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      el.connectBtn.addEventListener('click', () => void connect());
      el.disconnectBtn.addEventListener('click', disconnect);
      el.chatSend.addEventListener('click', () => void sendChat());
      el.chatInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); void sendChat(); }
      });

      // Persist settings (skip relay URLs)
      for (const [key, elRef] of [['oc-gw-url', el.gwUrl], ['oc-gw-token', el.gwToken]]) {
        try { const v = localStorage.getItem(key); if (v && !v.includes('relay')) elRef.value = v; } catch {}
        elRef.addEventListener('change', () => { try { localStorage.setItem(key, elRef.value); } catch {} });
      }

      // Auto-connect from query params
      const params = new URLSearchParams(location.search);
      if (params.get('url')) {
        el.gwUrl.value = params.get('url');
        if (params.get('token')) el.gwToken.value = params.get('token');
        if (params.get('url') === 'sandbox') {
          document.getElementById('connForm').style.display = 'none';
        }
        history.replaceState(null, '', location.pathname);
        void connect();
      }
    </script>
  </body>
</html>
